
# Анализ алгоритмов сортировки и поиска

**Автор**: Балодис Илья Евгеньевич УИБО-14-24  

Сортировка выбором (Selection Sort)

Суть метода: Данный алгоритм последовательно обрабатывает массив. На каждом этапе он отыскивает наименьший элемент в необработанном сегменте списка и перемещает его на актуальную позицию, обменивая местами с элементом, который там currently находится.

Принцип работы: Процесс начинается с первого элемента массива, который считается началом неотсортированной области. Алгоритм сканирует эту область, находя самый маленький элемент, и меняет его местами с первым элементом неотсортированной части. Таким образом, отсортированная часть увеличивается на один элемент, а неотсортированная — уменьшается. Данный шаг повторяется для оставшейся неупорядоченной части до полного упорядочивания всего списка.

Вычислительная сложность: Эффективность алгоритма характеризуется квадратичной зависимостью от количества элементов (O(n²)) для всех сценариев — наилучшего, среднего и наихудшего.

Сортировка пузырьком (Bubble Sort)

Суть метода: Этот метод многократно просматривает список, попарно сопоставляя соседние значения. Если два соседних элемента расположены в неверном порядке, они меняются местами. Проходы повторяются до тех пор, пока массив не будет полностью упорядочен.

Принцип работы: Основной цикл выполняется (n-1) раз для массива из n элементов. Внутри него вложенный цикл обрабатывает еще не установленные на свои места элементы, попарно их сравнивая и производя обмен при необходимости. В результате каждого полного прохода самый крупный элемент из неотсортированной части "всплывает" к ее концу, как пузырёк. При наличии флага, отслеживающего факт обменов, можно завершить работу досрочно, если массив уже упорядочен.

Вычислительная сложность:

Наихудший сценарий (обратно упорядоченный массив): O(n²)

Наилучший сценарий (уже отсортированный массив): O(n)

Средний случай: O(n²)
Общее число операций сравнения в наихудшем случае пропорционально n*(n-1)/2.

Сортировка вставками (Insertion Sort)

Суть метода: Данный подход строит отсортированную последовательность поэтапно. Он обрабатывает элементы по одному, начиная со второго, и для каждого нового элемента находит ему правильную позицию внутри уже упорядоченной левой части списка, вставляя его туда.

Принцип работы: Внешний цикл последовательно берёт элементы, начиная с индекса 1. Текущий обрабатываемый элемент сохраняется в переменной-ключе. Внутренний цикл (часто реализуемый как while) сдвигает элементы отсортированного сегмента, которые больше ключа, вправо, освобождая место для его корректной вставки. Как только позиция найдена, ключевой элемент помещается в неё.

Вычислительная сложность:

Наихудший случай (обратный порядок): O(n²)

Наилучший случай (отсортированный массив): O(n)

Сортировка слиянием (Merge Sort)

Суть метода: Эта стратегия применяет парадигму "разделяй и властвуй". Исходный массив рекурсивно разбивается на две примерно равные половины до тех пор, пока не останутся подмассивы длиной в один элемент. Затем эти упорядоченные фрагменты сливаются в большие отсортированные массивы.

Принцип работы: Процесс состоит из двух основных фаз:

Декомпозиция: Массив последовательно делится пополам, пока не будет достигнут базовый случай — подмассив из одного элемента (считается отсортированным по умолчанию).

Слияние: На этой фазе пары отсортированных подмассивов объединяются в новый упорядоченный массив. Для этого создается результирующий массив, и с помощью трёх указателей (по одному на каждый из сливаемых массивов и на результирующий) выбирается наименьший из текущих элементов, который и добавляется в результат.

Вычислительная сложность: Сложность алгоритма составляет O(n log n) для всех случаев.

Сортировка Шелла (Shellsort)

Суть метода: Этот алгоритм — усовершенствованная версия сортировки вставками. Он сортирует элементы, расположенные на определённом расстоянии (шаге) друг от друга, формируя и упорядочивая подсписки с этим шагом. Шаг постепенно уменьшается до единицы.

Принцип работы: Работа начинается с выбора большого шага (например, n/2). Все элементы, отстоящие друг от друга на этом шаге, образуют подмассивы, которые сортируются с помощью модифицированной сортировки вставками. Затем шаг уменьшается (например, вдвое), и процесс повторяется. На последней итерации шаг становится равен 1, что эквивалентно обычной сортировке вставками, но к этому моменту массив уже почти упорядочен.

Вычислительная сложность: Сложность сильно зависит от выбранной последовательности шагов. В наилучшем случае может достигать O(n log n), в наихудшем — деградирует до O(n²).

Быстрая сортировка (Quick Sort)

Суть метода: Это ещё один алгоритм, основанный на принципе "разделяй и властвуй". Он выбирает в массиве "опорный" элемент и перераспределяет остальные элементы так, чтобы слева от опорного оказались меньшие элементы, а справа — большие. Затем алгоритм рекурсивно применяется к двум образовавшимся подмассивам.

Принцип работы: Ключевой шаг — процедура разбиения. Часто в качестве опоры выбирается последний или средний элемент. Алгоритм переставляет элементы массива на месте, без использования дополнительной памяти, так, что все элементы меньше опорного оказываются слева от него, а все большие — справа. После того как опорный элемент занял свою окончательную позицию, рекурсивно сортируются левый и правый подмассивы относительно него.

Вычислительная сложность:

Наилучший и средний случай: O(n log n)

Наихудший случай (когда опора всегда оказывается минимальным или максимальным элементом): O(n²)

Пирамидальная сортировка (Heapsort)

Суть метода: Алгоритм преобразует исходный массив в специальную древовидную структуру данных — "кучу" (max-heap), где родительский элемент всегда больше дочерних. Затем он последовательно извлекает максимальный элемент из кучи (который всегда находится в корне) и перестраивает её, пока вся куча не будет разобрана.

Принцип работы: Процесс состоит из двух этапов:

Построение кучи: Массив преобразуется в max-heap с помощью функции heapify, которая вызывается для всех нелистовых узлов, начиная с середины массива.

Извлечение: Максимальный элемент (корень) меняется местами с последним элементом кучи. "Куча" уменьшается на один элемент, и процедура heapify вызывается для нового корня, чтобы восстановить свойства кучи. Это повторяется, пока в куче не останется один элемент.

Вычислительная сложность: Сложность алгоритма всегда составляет O(n log n).

Линейный поиск (Sequential Search)

Суть метода: Самый простой способ поиска. Элементы просматриваются один за другим, от начала до конца коллекции, до тех пор, пока не будет найден искомый элемент или пока не будет достигнут конец списка.

Принцип работы: Алгоритм итерируется по массиву, на каждом шаге сравнивая текущий элемент с целевым значением. Если значения совпали, возвращается индекс найденного элемента. Если цикл завершился без нахождения, возвращается индикатор ошибки (например, -1).

Вычислительная сложность:

Наилучший случай: O(1) (элемент первый)

Средний и наихудший случаи: O(n)

Двоичный поиск (Binary Search)

Суть метода: Высокоэффективный алгоритм для поиска в отсортированном массиве. На каждом шаге он сравнивает искомое значение со средним элементом текущего диапазона поиска. В зависимости от результата сравнения, дальнейший поиск продолжается только в левой или правой половине диапазона, отбрасывая неподходящую половину.

Принцип работы: Инициализируются две границы — начальная и конечная. На каждой итерации вычисляется середина текущего интервала. Если средний элемент равен целевому, поиск завершён. Если целевое значение меньше среднего элемента, правая граница смещается перед серединой. Если больше — левая граница смещается после середины. Процесс повторяется, пока границы не "схлопнутся".

Вычислительная сложность: O(log n)

Интерполяционный поиск (Interpolation Search)

Суть метода: Улучшенная версия двоичного поиска для равномерно распределённых данных. Вместо деления области поиска пополам, он пытается предугадать вероятную позицию искомого элемента, используя формулу интерполяции, основанную на значениях границ и искомого числа.

Принцип работы: Алгоритм проверяет, находится ли искомое значение в пределах текущих границ. Затем, по специальной формуле, вычисляет предполагаемую позицию элемента. Сравнивает элемент в этой позиции с искомым и, в зависимости от результата, рекурсивно или итеративно сужает область поиска до левой или правой части.

Вычислительная сложность:

При равномерном распределении: O(log log n)

В наихудшем случае: O(n)

Поиск Фибоначчи (Fibonacci Search)

Суть метода: Ещё один алгоритм для отсортированных массивов, использующий числа Фибоначчи для определения точек сравнения. Похож на двоичный поиск, но делит массив не на две равные части, а на части, соотношение которых соответствует последовательным числам Фибоначчи.

Принцип работы: Сначала определяется наименьшее число Фибоначчи, которое больше или равно размеру массива. Затем поиск использует эти числа для определения индексов, с которыми следует сравнивать целевое значение. В зависимости от результата сравнения, область поиска сужается, а используемые числа Фибоначчи "откатываются" на шаг или два назад.

Вычислительная сложность: O(log n), что сопоставимо с двоичным поиском, но может иметь преимущества по константам в некоторых реализациях.
